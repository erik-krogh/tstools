These are some of the main sources of imprecision. 
Most of it are in the higher-levels, because that is the main contributer to the score that i compute. 

box2dweb: 
	Its leaking "i", "Vector" and "Vector_a2j_Number" to the global scope. (sent a pull-request to fix that). 
	
	In the declaration, the Box2D object only has Dynamics, Collision and Common. 
	But in reality, there also is parseUInt, NVector, inherit, is and generateCallback. 
	
	Longer down, there is a b2internal property, which isn't mentioned in the declaration. 
	
	The declaration files claims that there is a "Box2D.Collision.b2OBB" class, there isn't. 
	
	Box2D.Collision.b2TimeOfImpact, b2Bound, ClipVertex, b2SimplexVertex and a lot of other classes are apparently private. 
	

PIXI: 
	There is a bunch of classes, that simply aresn't on the heap after initialization: https://github.com/pixijs/pixi.js/issues/2312
	
	We have .fromFrame and .fromImage on Texture. These are classified as classes, because they are called with "new". 
	BUT, they return an instance of Textture instance, so the "new" in the source is actually misleading. // TODO: Make a pull-request.  
	
	And then a lot of ts-spec-reader issues, that makes it difficult to see what is actually missing. 
	
D3: 
	Mainly the ts-spec-reader bug. 
	And some imprecisions related to the number of arguments for functions. 
	
	.apply is damn hopeless like this: 
		d3.timer = function() {
			d3_timer.apply(this, arguments);
		};
		function d3_timer(callback, delay, then) {
		
	And then a lot either from the ts-spec-reader bug, ot simply imprecisions. 
	
	Our analysis cannot infer that a class can be called with anything but "new". 
	
Underscore: 
	Right now, the biggest source in the score is that the declaration states the class shouldn't be instantiated with "new", but just be called. 
	
	And all the prototype functions are called with Function.apply, and i've not been able to infer anything useful about them. 
	
Three.d.ts
	Lots of enums, that are just a imaginary-type, and aren't on the heap. 
	And instances of those, that the analysis wrongly says are numbers. But it cannot do anything else, because it IS a number, there is no enum.
	
	There is also a lot of fields that is misses. Tried to look into one of them. 
	There the fields are missing, because the analysis doesn't infer that the MultiMaterial inherits from Material. 
	Which isn't suppring considering this comment in the declaration: // MultiMaterial does not inherit the Material class in the original code. However, it should treat as Material class.
	Basically, the declaration is wrong, MultiMaterial doesn't extend Material, and they know it. 
	
	There is also something like THREE.WebGLShader. Which the declaration states is a class (wrong). It really is a function that returns something. 
	
	But not all just errors. There is also a lot of times where the analysis simply doesn't have the precision. Which is actually the main thing. 
	
Leaflet: 
	A LOT of private variables/ undocumented variables (no error there). 
	
	There is a lot of [what?]. 
	
	All the constructor signatures takes 0 arguments, beucase they use function.apply. 
	
	got simple type, expected interface RealType: window.L.LatLngBounds.[newSig0].[return]  myType: window.L.Path.[newSig0].[return]

	Has a really wierd prototype system, with mixins and options and stuff. So sometimes i miss some properties, even though there are there. 
	For Path i get it, you can see that Path extends some NewClass, but for Map I don't. Which gives me something like: property missing: doubleClickZoom Path: window.L.Map.[function].[return]
